# 数据结构本质上只有数组和链表

## 数组

数组是 **连续** 存储。

随机访问只需要用 **初始位地址**，加上 **偏移量** 就行，其复杂度为 $O(1)$。

### 队列

先进先出，前后都有出口。

> 可以用来，
>
> 1. 时间管理
> 2. 任务队列
> 3. 控制异步任务的并发数
>    ...

### 栈

先进后出，只有一个出口。

> JSX 和 Vue 的 Template 里都是通过栈这种数据结构来判断元素或组件是否匹配。

## 链表

链表是 **非连续**，**指向型** 的存储。

新增和删除的复杂度为 $O(1)$。

### 树

链表是每一个节点，只有一个指针，而树则是有多个指针。

> 树是前端最重要的数据结构。

### 图

如果在树结构的基础上，树的最外层子节点都有闭合节点的话，这就是图。

图是由 **顶点集合** 和 **顶点之间边的集合** 组成的。

G(V,E)

- G 表示图
- V 表示 G 中顶点的集合
- E 表示 G 中边的集合

如：

```js
// 4 => 1
// 5 => 3
        +----> 1
        |     / \
        |    2   3 <-+
        |   / \      |
        +- 4   5 ----+
```

> Vite / Webpack 里的任意 module 里都有的 ModuleGraph 用的是图。
>
> ModuleGraph 是内部的文件依赖图。
> 我们可以通过这个图来很快找到某个 module 是否重复加载了。

### 堆

> 理论上，所有的数据存储都是连续的。
>
> 只是链表会有指针存在。

### 链表 - 跳表

链表的缺点就是随机访问很慢，复杂度是 $O(n)$。

我们可以 **用空间换时间** 的方式来优化：

```
       g

  e         f

a => b => c => d
```

在 a 和 b 之间找一个值 e，
在 c 和 d 之间找一个值 f，
e 和 f 之间再找一个值 g，

这样链表就变成一个类似树的结构，

每两个节点之间用一个值来做缓存。

这样就可以使用 **二分查找** 了，这样复杂度就变成了 $O(log)$。

这就叫做 **跳表**，在 redis 里也有用到。

## 数组和链表结合

### JavaScript 对象

JS 中的对象其实是**数组+链表**。

比如我们有以下对象

```js
let obj = {
  a: 1;
  b: 2;
}
```

那在内存里，会有一块连续的空间（数组），存着所有的 `value`。

然后 `key` 指向各自的 `value`，

但 `key` 是字符串（甚至 Map 的 key 还能是其他任何数据结构），并不是数组的下标（数字），

所以还需要用 **hash 算法** 将 `key` 变成一个数字下标。

> 最简单的 hash 算法：
> 将每一个 ASCII 码值 \* 字数的结果求余。

当我们求 `obj['a']` a 的值时，

1. 会先算出 hash 值，
2. 通过 hash 算法计算出来的下标，找到对应位置的值，并返回。

对象的查找的查找速度和其数据量无关。

因为都只是求出偏差值，然后在值的数组中随机访问即可。

其查找数据的复杂度是 $O(1)$。

> JS 对象在算法领域叫 **hash table**。

> hash 算法会有一些问题：
> 比如不同的 `key`，计算出了同样的下标。
>
> 这时候可以
>
> 1. **扩容**，**把这个连续的空间乘以二**
>
> 2. **在该下标位置放入一个链表**，链表里，第一个 `key` 指向第二个 `key`。
>    先查到第一个 `key` 再遍历链表去查第二个 `key`。
